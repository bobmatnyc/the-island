#!/usr/bin/env python3
"""
Entity Disambiguation Service
Handles name normalization and alias resolution for entity queries

Design Decision: Dynamic Mapping Loading
Rationale: Load entity name mappings from JSON file generated by build_entity_mappings.py
instead of hardcoding aliases. This allows offline mapping updates without code changes.

Fallback Strategy: If mapping file not found, use empty mappings and rely on whitespace
normalization only. Logs warning but doesn't fail.

Trade-offs:
- Maintainability: Single source of truth for name mappings (JSON file)
- Performance: One-time file load on initialization (~265 mappings)
- Flexibility: Can update mappings without server restart (reload service)
"""

import json
import re
from pathlib import Path
from typing import Optional


class EntityDisambiguation:
    """Service for resolving entity name variations to canonical forms"""

    # Entity aliases loaded from JSON file
    ENTITY_ALIASES: dict[str, str] = {}

    # Reverse mapping: canonical -> all known variations
    CANONICAL_TO_VARIATIONS: dict[str, set[str]] = {}

    def __init__(self, mappings_path: Optional[Path] = None):
        """Initialize disambiguation service and load mappings

        Args:
            mappings_path: Path to entity_name_mappings.json
                          If None, uses default location
        """
        if mappings_path is None:
            # Default path relative to server directory
            server_dir = Path(__file__).parent.parent
            project_root = server_dir.parent
            mappings_path = project_root / "data" / "metadata" / "entity_name_mappings.json"

        self._load_mappings(mappings_path)
        self._load_entity_aliases()
        self._build_reverse_mappings()

    def _load_mappings(self, mappings_path: Path) -> None:
        """Load entity name mappings from JSON file

        Args:
            mappings_path: Path to entity_name_mappings.json

        Side Effects:
            Populates self.ENTITY_ALIASES with loaded mappings
            Logs warning if file not found but doesn't fail

        Design Decision: Handle both old and new formats
        Rationale: Post-migration, file has {name_to_id: {}} structure
        Pre-migration, it was just {name: canonical_name}
        """
        if not mappings_path.exists():
            print(f"Warning: Entity mappings file not found at {mappings_path}")
            print("Run: python3 scripts/utils/build_entity_mappings.py")
            print("Using empty mappings (whitespace normalization only)")
            self.ENTITY_ALIASES = {}
            return

        try:
            with open(mappings_path) as f:
                data = json.load(f)

            # Check if this is the new format with name_to_id
            if isinstance(data, dict) and "name_to_id" in data:
                # New format: {name_to_id: {name: id}}
                # We don't use this for disambiguation anymore since we have entity IDs
                # Just initialize empty dict
                self.ENTITY_ALIASES = {}
                print(
                    f"Loaded entity mappings (new ID-based format, {len(data.get('name_to_id', {}))} variants)"
                )
            else:
                # Old format: {name: canonical_name}
                self.ENTITY_ALIASES = data
                print(f"Loaded {len(self.ENTITY_ALIASES)} entity name mappings")
        except Exception as e:
            print(f"Error loading entity mappings: {e}")
            print("Using empty mappings (whitespace normalization only)")
            self.ENTITY_ALIASES = {}

    def _load_entity_aliases(self) -> None:
        """Load entity aliases from ENTITIES_INDEX.json

        This loads aliases defined in the entity index (e.g., "Bill Clinton" -> "William Clinton")
        and merges them with the existing mappings.

        Side Effects:
            Adds alias mappings to self.ENTITY_ALIASES
        """
        server_dir = Path(__file__).parent.parent
        project_root = server_dir.parent
        entities_index_path = project_root / "data" / "md" / "entities" / "ENTITIES_INDEX.json"

        if not entities_index_path.exists():
            print(f"Warning: ENTITIES_INDEX.json not found at {entities_index_path}")
            return

        try:
            with open(entities_index_path) as f:
                data = json.load(f)
                entities = data.get("entities", [])

                alias_count = 0
                for entity in entities:
                    canonical_name = entity.get("name")
                    aliases = entity.get("aliases", [])

                    if canonical_name and aliases:
                        # Map each alias to the canonical name
                        for alias in aliases:
                            if alias and alias != canonical_name:
                                self.ENTITY_ALIASES[alias] = canonical_name
                                alias_count += 1

                if alias_count > 0:
                    print(f"Loaded {alias_count} entity aliases from ENTITIES_INDEX.json")

        except Exception as e:
            print(f"Warning: Error loading entity aliases: {e}")

    def _build_reverse_mappings(self) -> None:
        """Build canonical -> variations reverse index"""
        for variation, canonical in self.ENTITY_ALIASES.items():
            if canonical not in self.CANONICAL_TO_VARIATIONS:
                self.CANONICAL_TO_VARIATIONS[canonical] = {canonical}
            self.CANONICAL_TO_VARIATIONS[canonical].add(variation)

    def normalize_name(self, name: str) -> str:
        """Normalize entity name to canonical form

        Args:
            name: Input name (may be variation or canonical)

        Returns:
            Canonical name or original if no mapping exists

        Examples:
            >>> disambiguator.normalize_name("Je Je Epstein")
            "Jeffrey Epstein"
            >>> disambiguator.normalize_name("Ghislaine Ghislaine")
            "Ghislaine Maxwell"
        """
        # Direct alias lookup
        if name in self.ENTITY_ALIASES:
            return self.ENTITY_ALIASES[name]

        # Remove extra whitespace (common OCR issue)
        cleaned = re.sub(r"\s+", " ", name.strip())
        if cleaned in self.ENTITY_ALIASES:
            return self.ENTITY_ALIASES[cleaned]

        # Check for duplicated first names pattern (OCR artifact)
        # Example: "John      John Smith" -> "John Smith"
        parts = cleaned.split()
        if len(parts) >= 2 and parts[0] == parts[1]:
            deduplicated = " ".join(parts[1:])
            if deduplicated in self.ENTITY_ALIASES:
                return self.ENTITY_ALIASES[deduplicated]
            # Return deduplicated form even if not in aliases
            return deduplicated

        # Return original name if no normalization found
        return name

    def get_all_variations(self, canonical_name: str) -> set[str]:
        """Get all known variations for a canonical name

        Args:
            canonical_name: Canonical form of entity name

        Returns:
            Set of all known variations (including canonical)

        Examples:
            >>> disambiguator.get_all_variations("Jeffrey Epstein")
            {"Jeffrey Epstein", "Je Je Epstein", "Je Epstein", "JE", ...}
        """
        return self.CANONICAL_TO_VARIATIONS.get(canonical_name, {canonical_name})

    def search_entity(self, query: str, entity_dict: dict[str, any]) -> Optional[any]:
        """Search entity dictionary with disambiguation support

        Args:
            query: Search query (may be canonical or variation)
            entity_dict: Dictionary keyed by entity names

        Returns:
            Entity data if found, None otherwise

        Examples:
            >>> data = disambiguator.search_entity("Je Je Epstein", entities)
            # Searches for "Jeffrey Epstein" if no direct match
        """
        # Direct match first
        if query in entity_dict:
            return entity_dict[query]

        # Try normalized form
        canonical = self.normalize_name(query)
        if canonical in entity_dict:
            return entity_dict[canonical]

        # Try all variations of canonical form
        for variation in self.get_all_variations(canonical):
            if variation in entity_dict:
                return entity_dict[variation]

        # Case-insensitive fallback
        query_lower = query.lower()
        for entity_name, entity_data in entity_dict.items():
            if entity_name.lower() == query_lower:
                return entity_data

        return None

    def merge_duplicate_nodes(self, nodes: list[dict]) -> list[dict]:
        """Merge duplicate entity nodes based on canonical names

        Args:
            nodes: List of entity nodes with 'name' field

        Returns:
            Deduplicated list of nodes with merged connection counts

        Design Decision: Name Deduplication Strategy

        Rationale: Flight logs contain OCR artifacts with duplicated first names
        ("Je        Je Epstein", "Ghislaine Ghislaine", etc.). This creates
        duplicate nodes in network graphs and inflates entity counts.

        Approach: Normalize all names to canonical form, merge nodes with same
        canonical name by summing their connection_count and flight_count.

        Trade-offs:
        - Accuracy vs. Deduplication: Aggressive normalization risks merging
          distinct entities with similar names. Mitigated by explicit alias
          dictionary rather than fuzzy matching.
        - Performance: O(n) pass over nodes, acceptable for <10k entities
        - Data Loss: Preserves billionaire status, categories via union

        Examples:
            Input: [{"name": "Je Je Epstein", "connection_count": 162},
                    {"name": "Jeffrey Epstein", "connection_count": 50}]
            Output: [{"name": "Jeffrey Epstein", "connection_count": 212}]
        """
        canonical_nodes: dict[str, dict] = {}

        for node in nodes:
            original_name = node.get("name", node.get("id", ""))
            canonical_name = self.normalize_name(original_name)

            if canonical_name in canonical_nodes:
                # Merge with existing canonical node
                existing = canonical_nodes[canonical_name]
                existing["connection_count"] = existing.get("connection_count", 0) + node.get(
                    "connection_count", 0
                )
                existing["flight_count"] = existing.get("flight_count", 0) + node.get(
                    "flight_count", 0
                )
                # Preserve billionaire status if either is true
                existing["is_billionaire"] = existing.get("is_billionaire", False) or node.get(
                    "is_billionaire", False
                )
                # Union of categories
                existing_cats = set(existing.get("categories", []))
                new_cats = set(node.get("categories", []))
                existing["categories"] = list(existing_cats | new_cats)
            else:
                # Create new canonical node
                canonical_node = node.copy()
                canonical_node["name"] = canonical_name
                canonical_node["id"] = canonical_name
                canonical_node["original_names"] = [original_name]
                canonical_nodes[canonical_name] = canonical_node

        return list(canonical_nodes.values())

    def deduplicate_edges(self, edges: list[dict], node_mapping: dict[str, str]) -> list[dict]:
        """Deduplicate network edges after node merging

        Args:
            edges: List of edges with 'source', 'target', 'weight' fields
            node_mapping: Mapping from original names to canonical names

        Returns:
            Deduplicated edges with merged weights

        Design Decision: Edge Consolidation

        After merging duplicate nodes, edges between the same canonical entities
        must be consolidated. Multiple edges may exist due to OCR name variations.

        Approach: Update source/target to canonical names, merge edges with same
        (source, target) pair by summing weights.

        Examples:
            Input: [{"source": "Je Je Epstein", "target": "Ghislaine Ghislaine", "weight": 100},
                    {"source": "Jeffrey Epstein", "target": "Ghislaine Maxwell", "weight": 128}]
            Output: [{"source": "Jeffrey Epstein", "target": "Ghislaine Maxwell", "weight": 228}]
        """
        canonical_edges: dict[tuple[str, str], dict] = {}

        for edge in edges:
            source_canonical = self.normalize_name(edge.get("source", ""))
            target_canonical = self.normalize_name(edge.get("target", ""))

            # Skip self-loops
            if source_canonical == target_canonical:
                continue

            # Normalize edge direction (ensure consistent ordering)
            edge_key = tuple(sorted([source_canonical, target_canonical]))

            if edge_key in canonical_edges:
                # Merge weights
                canonical_edges[edge_key]["weight"] += edge.get("weight", 1)
            else:
                # Create new canonical edge
                canonical_edges[edge_key] = {
                    "source": edge_key[0],
                    "target": edge_key[1],
                    "weight": edge.get("weight", 1),
                    "label": edge.get("label", ""),
                }

        return list(canonical_edges.values())

    def add_alias(self, variation: str, canonical: str) -> None:
        """Add new alias mapping dynamically

        Args:
            variation: Name variation to map
            canonical: Canonical form to map to
        """
        self.ENTITY_ALIASES[variation] = canonical
        if canonical not in self.CANONICAL_TO_VARIATIONS:
            self.CANONICAL_TO_VARIATIONS[canonical] = {canonical}
        self.CANONICAL_TO_VARIATIONS[canonical].add(variation)


# Global singleton instance
_disambiguator_instance: Optional[EntityDisambiguation] = None


def get_disambiguator() -> EntityDisambiguation:
    """Get global EntityDisambiguation instance (lazy singleton)"""
    global _disambiguator_instance
    if _disambiguator_instance is None:
        _disambiguator_instance = EntityDisambiguation()
    return _disambiguator_instance
